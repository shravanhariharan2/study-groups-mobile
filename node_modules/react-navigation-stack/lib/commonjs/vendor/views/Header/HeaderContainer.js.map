{"version":3,"sources":["HeaderContainer.tsx"],"names":["HeaderContainer","mode","scenes","layout","insets","state","getPreviousRoute","onContentHeightChange","styleInterpolator","style","focusedRoute","routes","index","map","scene","i","self","length","options","descriptor","isFocused","key","route","previousRoute","previous","j","s","previousScene","nextScene","isHeaderStatic","headerShown","props","navigation","forStatic","e","height","nativeEvent","undefined","headerTransparent","styles","header","StyleSheet","create","position","top","left","right"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { View, StyleSheet, StyleProp, ViewStyle } from 'react-native';\nimport { NavigationContext } from 'react-navigation';\nimport { NavigationState as StackNavigationState } from 'react-navigation';\nimport { EdgeInsets } from 'react-native-safe-area-context';\n\nimport Header from './Header';\nimport { forStatic } from '../../TransitionConfigs/HeaderStyleInterpolators';\nimport {\n  Route,\n  Layout,\n  Scene,\n  StackHeaderStyleInterpolator,\n  StackNavigationProp,\n} from '../../types';\n\nexport type Props = {\n  mode: 'float' | 'screen';\n  layout: Layout;\n  insets: EdgeInsets;\n  scenes: (Scene<Route<string>> | undefined)[];\n  state: StackNavigationState;\n  getPreviousRoute: (props: {\n    route: Route<string>;\n  }) => Route<string> | undefined;\n  onContentHeightChange?: (props: {\n    route: Route<string>;\n    height: number;\n  }) => void;\n  styleInterpolator: StackHeaderStyleInterpolator;\n  style?: StyleProp<ViewStyle>;\n};\n\nexport default function HeaderContainer({\n  mode,\n  scenes,\n  layout,\n  insets,\n  state,\n  getPreviousRoute,\n  onContentHeightChange,\n  styleInterpolator,\n  style,\n}: Props) {\n  const focusedRoute = state.routes[state.index];\n\n  return (\n    <View pointerEvents=\"box-none\" style={style}>\n      {scenes.map((scene, i, self) => {\n        if ((mode === 'screen' && i !== self.length - 1) || !scene) {\n          return null;\n        }\n\n        const { options } = scene.descriptor;\n        const isFocused = focusedRoute.key === scene.route.key;\n        const previousRoute = getPreviousRoute({ route: scene.route });\n\n        let previous;\n\n        if (previousRoute) {\n          // The previous scene will be shortly before the current scene in the array\n          // So loop back from current index to avoid looping over the full array\n          for (let j = i - 1; j >= 0; j--) {\n            const s = self[j];\n\n            if (s && s.route.key === previousRoute.key) {\n              previous = s;\n              break;\n            }\n          }\n        }\n\n        // If the screen is next to a headerless screen, we need to make the header appear static\n        // This makes the header look like it's moving with the screen\n        const previousScene = self[i - 1];\n        const nextScene = self[i + 1];\n        const isHeaderStatic =\n          mode === 'float'\n            ? (previousScene &&\n                previousScene.descriptor.options.headerShown === false &&\n                // We still need to animate when coming back from next scene\n                // A hacky way to check this is if the next scene exists\n                !nextScene) ||\n              (nextScene && nextScene.descriptor.options.headerShown === false)\n            : false;\n\n        const props = {\n          mode,\n          layout,\n          insets,\n          scene,\n          previous,\n          navigation: scene.descriptor.navigation as StackNavigationProp,\n          styleInterpolator: isHeaderStatic ? forStatic : styleInterpolator,\n        };\n\n        return (\n          <NavigationContext.Provider\n            key={scene.route.key}\n            value={scene.descriptor.navigation}\n          >\n            <View\n              onLayout={\n                onContentHeightChange\n                  ? e =>\n                      onContentHeightChange({\n                        route: scene.route,\n                        height: e.nativeEvent.layout.height,\n                      })\n                  : undefined\n              }\n              pointerEvents={isFocused ? 'box-none' : 'none'}\n              accessibilityElementsHidden={!isFocused}\n              importantForAccessibility={\n                isFocused ? 'auto' : 'no-hide-descendants'\n              }\n              style={\n                mode === 'float' || options.headerTransparent\n                  ? styles.header\n                  : null\n              }\n            >\n              {options.headerShown !== false ? (\n                options.header !== undefined ? (\n                  options.header(props)\n                ) : (\n                  <Header {...props} />\n                )\n              ) : null}\n            </View>\n          </NavigationContext.Provider>\n        );\n      })}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n  },\n});\n"]}